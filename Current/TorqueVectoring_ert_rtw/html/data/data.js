var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"TorqueVectoring","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\eiakim\\Downloads\\ControlSystemsMPC-main\\ControlSystemsMPC-main\\Current\\TorqueVectoring_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'TorqueVectoring'.\r\n *\r\n * Model version                  : 1.0\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Mar 27 18:22:20 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"TorqueVectoring.h\"           /* Model's header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(rtM, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  TorqueVectoring_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example \"main\" function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific.  This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  TorqueVectoring_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.001 seconds (the model's base sample time) here.  The\r\n   * call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  /* Disable rt_OneStep here */\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"TorqueVectoring.c","type":"source","group":"model","path":"C:\\Users\\eiakim\\Downloads\\ControlSystemsMPC-main\\ControlSystemsMPC-main\\Current\\TorqueVectoring_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: TorqueVectoring.c\r\n *\r\n * Code generated for Simulink model 'TorqueVectoring'.\r\n *\r\n * Model version                  : 1.0\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Mar 27 18:22:20 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"TorqueVectoring.h\"\r\n\r\n/* Named constants for MATLAB Function: '<S41>/FixedHorizonOptimizer' */\r\n#define Wdu                            (0.010000000000000002)\r\n#define Wu                             (0.0)\r\n#define ny                             (3)\r\n#define NumBitsPerChar                 8U\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY rtY;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\nextern real_T rt_powd_snf(real_T u0, real_T u1);\r\n\r\n/* Forward declaration for local functions */\r\nstatic void WtMult(real_T W, const real_T M[20], real_T WM[20]);\r\nstatic int32_T xpotrf(real_T b_A[4]);\r\nstatic void trisolve(const real_T b_A[4], real_T b_B[4]);\r\nstatic void mpcblock_optimizer(const real_T rseq[30], const real_T vseq[11],\r\n  const real_T x[6], real_T old_u, boolean_T iA, const real_T b_utarget[10],\r\n  real_T b_uoff, const real_T b_A[36], const real_T Bu[66], const real_T Bv[66],\r\n  const real_T b_C[18], const real_T Dv[33], real_T *u, real_T useq[11], real_T *\r\n  status, boolean_T *iAout);\r\nstatic real_T rtGetInf(void);\r\nstatic real32_T rtGetInfF(void);\r\nstatic real_T rtGetMinusInf(void);\r\nstatic real32_T rtGetMinusInfF(void);\r\nstatic real_T rtGetNaN(void);\r\nstatic real32_T rtGetNaNF(void);\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nstatic void rt_InitInfAndNaN(size_t realSize);\r\nstatic boolean_T rtIsInf(real_T value);\r\nstatic boolean_T rtIsInfF(real32_T value);\r\nstatic boolean_T rtIsNaN(real_T value);\r\nstatic boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic void rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nstatic boolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nstatic boolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nstatic boolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nstatic boolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/* Function for MATLAB Function: '<S41>/FixedHorizonOptimizer' */\r\nstatic void WtMult(real_T W, const real_T M[20], real_T WM[20])\r\n{\r\n  int32_T i;\r\n  for (i = 0; i < 10; i++) {\r\n    WM[i] = W * M[i];\r\n    WM[i + 10] = M[i + 10] * W;\r\n  }\r\n}\r\n\r\n/* Function for MATLAB Function: '<S41>/FixedHorizonOptimizer' */\r\nstatic int32_T xpotrf(real_T b_A[4])\r\n{\r\n  int32_T info;\r\n  int32_T ix;\r\n  int32_T j;\r\n  boolean_T exitg1;\r\n  info = 0;\r\n  j = 0;\r\n  exitg1 = false;\r\n  while ((!exitg1) && (j < 2)) {\r\n    real_T ssq;\r\n    int32_T idxAjj;\r\n    idxAjj = (j << 1) + j;\r\n    ssq = 0.0;\r\n    if (j >= 1) {\r\n      ssq = b_A[1] * b_A[1];\r\n    }\r\n\r\n    ssq = b_A[idxAjj] - ssq;\r\n    if (ssq > 0.0) {\r\n      ssq = sqrt(ssq);\r\n      b_A[idxAjj] = ssq;\r\n      if (j + 1 < 2) {\r\n        ssq = 1.0 / ssq;\r\n        for (ix = idxAjj + 1; ix < idxAjj + 2; ix++) {\r\n          b_A[ix] *= ssq;\r\n        }\r\n      }\r\n\r\n      j++;\r\n    } else {\r\n      b_A[idxAjj] = ssq;\r\n      info = j + 1;\r\n      exitg1 = true;\r\n    }\r\n  }\r\n\r\n  return info;\r\n}\r\n\r\nreal_T rt_powd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else {\r\n    real_T tmp;\r\n    real_T tmp_0;\r\n    tmp = fabs(u0);\r\n    tmp_0 = fabs(u1);\r\n    if (rtIsInf(u1)) {\r\n      if (tmp == 1.0) {\r\n        y = 1.0;\r\n      } else if (tmp > 1.0) {\r\n        if (u1 > 0.0) {\r\n          y = (rtInf);\r\n        } else {\r\n          y = 0.0;\r\n        }\r\n      } else if (u1 > 0.0) {\r\n        y = 0.0;\r\n      } else {\r\n        y = (rtInf);\r\n      }\r\n    } else if (tmp_0 == 0.0) {\r\n      y = 1.0;\r\n    } else if (tmp_0 == 1.0) {\r\n      if (u1 > 0.0) {\r\n        y = u0;\r\n      } else {\r\n        y = 1.0 / u0;\r\n      }\r\n    } else if (u1 == 2.0) {\r\n      y = u0 * u0;\r\n    } else if ((u1 == 0.5) && (u0 >= 0.0)) {\r\n      y = sqrt(u0);\r\n    } else if ((u0 < 0.0) && (u1 > floor(u1))) {\r\n      y = (rtNaN);\r\n    } else {\r\n      y = pow(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S41>/FixedHorizonOptimizer' */\r\nstatic void trisolve(const real_T b_A[4], real_T b_B[4])\r\n{\r\n  if (b_B[0] != 0.0) {\r\n    b_B[0] /= b_A[0];\r\n    b_B[1] -= b_B[0] * b_A[1];\r\n  }\r\n\r\n  if (b_B[1] != 0.0) {\r\n    b_B[1] /= b_A[3];\r\n  }\r\n\r\n  if (b_B[2] != 0.0) {\r\n    b_B[2] /= b_A[0];\r\n    b_B[3] -= b_A[1] * b_B[2];\r\n  }\r\n\r\n  if (b_B[3] != 0.0) {\r\n    b_B[3] /= b_A[3];\r\n  }\r\n}\r\n\r\n/* Function for MATLAB Function: '<S41>/FixedHorizonOptimizer' */\r\nstatic void mpcblock_optimizer(const real_T rseq[30], const real_T vseq[11],\r\n  const real_T x[6], real_T old_u, boolean_T iA, const real_T b_utarget[10],\r\n  real_T b_uoff, const real_T b_A[36], const real_T Bu[66], const real_T Bv[66],\r\n  const real_T b_C[18], const real_T Dv[33], real_T *u, real_T useq[11], real_T *\r\n  status, boolean_T *iAout)\r\n{\r\n  real_T c_Hv[330];\r\n  real_T Su[300];\r\n  real_T c_a[180];\r\n  real_T WySuJm[60];\r\n  real_T c_SuJm[60];\r\n  real_T CA_0[33];\r\n  real_T Sum_0[30];\r\n  real_T b_a[30];\r\n  real_T c_Kv[22];\r\n  real_T I2Jm[20];\r\n  real_T WuI2Jm[20];\r\n  real_T tmp[20];\r\n  real_T CA[18];\r\n  real_T CA_1[18];\r\n  real_T c_Kx[12];\r\n  real_T c[4];\r\n  real_T c_Linv[4];\r\n  real_T c_SuJm_0[4];\r\n  real_T Sum[3];\r\n  real_T b_C_0[3];\r\n  real_T b_a_0[2];\r\n  real_T c_Ku1[2];\r\n  real_T varargin_1[2];\r\n  real_T normH;\r\n  real_T s;\r\n  int32_T CA_tmp;\r\n  int32_T c_Hv_tmp;\r\n  int32_T i;\r\n  int32_T i_0;\r\n  int32_T kidx;\r\n  int16_T ixw;\r\n  int8_T a[100];\r\n  int8_T rows[3];\r\n  static const int8_T c_A[100] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0,\r\n    0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1,\r\n    1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,\r\n    0, 0, 0, 0, 0, 0, 1 };\r\n\r\n  static const real_T b_b[20] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\r\n\r\n  static const int8_T W[3] = { 1, 0, 0 };\r\n\r\n  static const int8_T c_0[20] = { 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0 };\r\n\r\n  boolean_T guard1 = false;\r\n  memset(&useq[0], 0, 11U * sizeof(real_T));\r\n  *iAout = false;\r\n  for (i = 0; i < 3; i++) {\r\n    Sum[i] = 0.0;\r\n    b_C_0[i] = 0.0;\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 6; c_Hv_tmp++) {\r\n      CA_tmp = 3 * c_Hv_tmp + i;\r\n      CA[CA_tmp] = 0.0;\r\n      for (i_0 = 0; i_0 < 6; i_0++) {\r\n        CA[CA_tmp] += b_C[3 * i_0 + i] * b_A[6 * c_Hv_tmp + i_0];\r\n      }\r\n\r\n      normH = b_C[CA_tmp];\r\n      Sum[i] += normH * Bu[c_Hv_tmp];\r\n      b_C_0[i] += normH * Bv[c_Hv_tmp];\r\n    }\r\n\r\n    c_Hv[i] = b_C_0[i];\r\n    c_Hv[i + 30] = Dv[i];\r\n  }\r\n\r\n  for (i = 0; i < 9; i++) {\r\n    c_Hv_tmp = (i + 2) * 30;\r\n    c_Hv[c_Hv_tmp] = 0.0;\r\n    c_Hv[c_Hv_tmp + 1] = 0.0;\r\n    c_Hv[c_Hv_tmp + 2] = 0.0;\r\n  }\r\n\r\n  for (i = 0; i < 11; i++) {\r\n    memset(&c_Hv[i * 30 + 3], 0, 27U * sizeof(real_T));\r\n  }\r\n\r\n  for (i = 0; i < 6; i++) {\r\n    c_a[30 * i] = CA[3 * i];\r\n    c_a[30 * i + 1] = CA[3 * i + 1];\r\n    c_a[30 * i + 2] = CA[3 * i + 2];\r\n    memset(&c_a[i * 30 + 3], 0, 27U * sizeof(real_T));\r\n  }\r\n\r\n  b_a[0] = Sum[0];\r\n  b_a[1] = Sum[1];\r\n  b_a[2] = Sum[2];\r\n  memset(&b_a[3], 0, 27U * sizeof(real_T));\r\n  Su[0] = Sum[0];\r\n  Su[1] = Sum[1];\r\n  Su[2] = Sum[2];\r\n  for (i = 0; i < 9; i++) {\r\n    c_Hv_tmp = (i + 1) * 30;\r\n    Su[c_Hv_tmp] = 0.0;\r\n    Su[c_Hv_tmp + 1] = 0.0;\r\n    Su[c_Hv_tmp + 2] = 0.0;\r\n  }\r\n\r\n  for (i = 0; i < 10; i++) {\r\n    memset(&Su[i * 30 + 3], 0, 27U * sizeof(real_T));\r\n  }\r\n\r\n  for (kidx = 0; kidx < 9; kidx++) {\r\n    int8_T kidx_0;\r\n    kidx_0 = (int8_T)((kidx + 1) * 3 + 1);\r\n    for (i = 0; i < 3; i++) {\r\n      rows[i] = (int8_T)(i + kidx_0);\r\n      normH = 0.0;\r\n      for (c_Hv_tmp = 0; c_Hv_tmp < 6; c_Hv_tmp++) {\r\n        normH += CA[3 * c_Hv_tmp + i] * Bu[c_Hv_tmp];\r\n      }\r\n\r\n      Sum[i] += normH;\r\n    }\r\n\r\n    b_a[rows[0] - 1] = Sum[0];\r\n    Sum_0[0] = Sum[0];\r\n    b_a[rows[1] - 1] = Sum[1];\r\n    Sum_0[1] = Sum[1];\r\n    b_a[rows[2] - 1] = Sum[2];\r\n    Sum_0[2] = Sum[2];\r\n    for (i = 0; i < 9; i++) {\r\n      c_Hv_tmp = (i + 1) * 3;\r\n      Sum_0[c_Hv_tmp] = Su[(30 * i + rows[0]) - 4];\r\n      Sum_0[c_Hv_tmp + 1] = Su[(30 * i + rows[1]) - 4];\r\n      Sum_0[c_Hv_tmp + 2] = Su[(30 * i + rows[2]) - 4];\r\n    }\r\n\r\n    for (i = 0; i < 10; i++) {\r\n      Su[(rows[0] + 30 * i) - 1] = Sum_0[3 * i];\r\n      Su[(rows[1] + 30 * i) - 1] = Sum_0[3 * i + 1];\r\n      Su[(rows[2] + 30 * i) - 1] = Sum_0[3 * i + 2];\r\n    }\r\n\r\n    for (i = 0; i < 3; i++) {\r\n      b_C_0[i] = 0.0;\r\n      for (c_Hv_tmp = 0; c_Hv_tmp < 6; c_Hv_tmp++) {\r\n        b_C_0[i] += CA[3 * c_Hv_tmp + i] * Bv[c_Hv_tmp];\r\n      }\r\n\r\n      CA_0[i] = b_C_0[i];\r\n    }\r\n\r\n    for (i = 0; i < 10; i++) {\r\n      CA_tmp = (i + 1) * 3;\r\n      CA_0[CA_tmp] = c_Hv[(30 * i + rows[0]) - 4];\r\n      CA_0[CA_tmp + 1] = c_Hv[(30 * i + rows[1]) - 4];\r\n      CA_0[CA_tmp + 2] = c_Hv[(30 * i + rows[2]) - 4];\r\n    }\r\n\r\n    for (i = 0; i < 11; i++) {\r\n      c_Hv[(rows[0] + 30 * i) - 1] = CA_0[3 * i];\r\n      c_Hv[(rows[1] + 30 * i) - 1] = CA_0[3 * i + 1];\r\n      c_Hv[(rows[2] + 30 * i) - 1] = CA_0[3 * i + 2];\r\n    }\r\n\r\n    for (i = 0; i < 3; i++) {\r\n      for (c_Hv_tmp = 0; c_Hv_tmp < 6; c_Hv_tmp++) {\r\n        CA_tmp = 3 * c_Hv_tmp + i;\r\n        CA_1[CA_tmp] = 0.0;\r\n        for (i_0 = 0; i_0 < 6; i_0++) {\r\n          CA_1[CA_tmp] += CA[3 * i_0 + i] * b_A[6 * c_Hv_tmp + i_0];\r\n        }\r\n      }\r\n    }\r\n\r\n    memcpy(&CA[0], &CA_1[0], 18U * sizeof(real_T));\r\n    for (i = 0; i < 6; i++) {\r\n      c_a[(rows[0] + 30 * i) - 1] = CA[3 * i];\r\n      c_a[(rows[1] + 30 * i) - 1] = CA[3 * i + 1];\r\n      c_a[(rows[2] + 30 * i) - 1] = CA[3 * i + 2];\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < 2; i++) {\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 30; c_Hv_tmp++) {\r\n      kidx = 30 * i + c_Hv_tmp;\r\n      c_SuJm[kidx] = 0.0;\r\n      for (i_0 = 0; i_0 < 10; i_0++) {\r\n        c_SuJm[kidx] += Su[30 * i_0 + c_Hv_tmp] * b_b[10 * i + i_0];\r\n      }\r\n    }\r\n  }\r\n\r\n  kidx = -1;\r\n  for (i = 0; i < 10; i++) {\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 10; c_Hv_tmp++) {\r\n      a[(kidx + c_Hv_tmp) + 1] = c_A[10 * i + c_Hv_tmp];\r\n    }\r\n\r\n    kidx += 10;\r\n  }\r\n\r\n  for (i = 0; i < 2; i++) {\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 10; c_Hv_tmp++) {\r\n      kidx = 10 * i + c_Hv_tmp;\r\n      I2Jm[kidx] = 0.0;\r\n      for (i_0 = 0; i_0 < 10; i_0++) {\r\n        I2Jm[kidx] += (real_T)a[10 * i_0 + c_Hv_tmp] * b_b[10 * i + i_0];\r\n      }\r\n    }\r\n  }\r\n\r\n  ixw = 1;\r\n  for (kidx = 0; kidx < 30; kidx++) {\r\n    i = W[ixw - 1];\r\n    WySuJm[kidx] = (real_T)i * c_SuJm[kidx];\r\n    WySuJm[kidx + 30] = c_SuJm[kidx + 30] * (real_T)i;\r\n    ixw++;\r\n    if (ixw > 3) {\r\n      ixw = 1;\r\n    }\r\n  }\r\n\r\n  WtMult(Wu, I2Jm, WuI2Jm);\r\n  WtMult(Wdu, b_b, tmp);\r\n  for (i = 0; i < 2; i++) {\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 2; c_Hv_tmp++) {\r\n      kidx = (c_Hv_tmp << 1) + i;\r\n      c_SuJm_0[kidx] = 0.0;\r\n      for (i_0 = 0; i_0 < 30; i_0++) {\r\n        c_SuJm_0[kidx] += c_SuJm[30 * i + i_0] * WySuJm[30 * c_Hv_tmp + i_0];\r\n      }\r\n\r\n      c[kidx] = 0.0;\r\n      normH = 0.0;\r\n      for (i_0 = 0; i_0 < 10; i_0++) {\r\n        CA_tmp = 10 * c_Hv_tmp + i_0;\r\n        normH += I2Jm[10 * i + i_0] * WuI2Jm[CA_tmp];\r\n        c[kidx] += (real_T)c_0[(i_0 << 1) + i] * tmp[CA_tmp];\r\n      }\r\n\r\n      c_Linv[kidx] = (c_SuJm_0[kidx] + c[kidx]) + normH;\r\n    }\r\n\r\n    b_a_0[i] = 0.0;\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 30; c_Hv_tmp++) {\r\n      b_a_0[i] += WySuJm[30 * i + c_Hv_tmp] * b_a[c_Hv_tmp];\r\n    }\r\n\r\n    varargin_1[i] = 0.0;\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 10; c_Hv_tmp++) {\r\n      varargin_1[i] += WuI2Jm[10 * i + c_Hv_tmp];\r\n    }\r\n\r\n    c_Ku1[i] = b_a_0[i] + varargin_1[i];\r\n  }\r\n\r\n  for (i = 0; i < 20; i++) {\r\n    WuI2Jm[i] = -WuI2Jm[i];\r\n  }\r\n\r\n  for (i = 0; i < 6; i++) {\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 2; c_Hv_tmp++) {\r\n      kidx = 6 * c_Hv_tmp + i;\r\n      c_Kx[kidx] = 0.0;\r\n      for (i_0 = 0; i_0 < 30; i_0++) {\r\n        c_Kx[kidx] += c_a[30 * i + i_0] * WySuJm[30 * c_Hv_tmp + i_0];\r\n      }\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < 11; i++) {\r\n    for (c_Hv_tmp = 0; c_Hv_tmp < 2; c_Hv_tmp++) {\r\n      kidx = 11 * c_Hv_tmp + i;\r\n      c_Kv[kidx] = 0.0;\r\n      for (i_0 = 0; i_0 < 30; i_0++) {\r\n        c_Kv[kidx] += c_Hv[30 * i + i_0] * WySuJm[30 * c_Hv_tmp + i_0];\r\n      }\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < 60; i++) {\r\n    WySuJm[i] = -WySuJm[i];\r\n  }\r\n\r\n  kidx = 0;\r\n  c_SuJm_0[0] = c_Linv[0];\r\n  c_SuJm_0[1] = c_Linv[1];\r\n  c_SuJm_0[2] = c_Linv[2];\r\n  c_SuJm_0[3] = c_Linv[3];\r\n  i = xpotrf(c_SuJm_0);\r\n  guard1 = false;\r\n  if (i == 0) {\r\n    if (c_SuJm_0[0] > c_SuJm_0[3]) {\r\n      normH = c_SuJm_0[3];\r\n    } else if (rtIsNaN(c_SuJm_0[0])) {\r\n      if (!rtIsNaN(c_SuJm_0[3])) {\r\n        normH = c_SuJm_0[3];\r\n      } else {\r\n        normH = c_SuJm_0[0];\r\n      }\r\n    } else {\r\n      normH = c_SuJm_0[0];\r\n    }\r\n\r\n    if (normH > 1.4901161193847656E-7) {\r\n    } else {\r\n      guard1 = true;\r\n    }\r\n  } else {\r\n    guard1 = true;\r\n  }\r\n\r\n  if (guard1) {\r\n    boolean_T exitg2;\r\n    normH = 0.0;\r\n    i = 0;\r\n    exitg2 = false;\r\n    while ((!exitg2) && (i < 2)) {\r\n      s = fabs(c_Linv[i + 2]) + fabs(c_Linv[i]);\r\n      if (rtIsNaN(s)) {\r\n        normH = (rtNaN);\r\n        exitg2 = true;\r\n      } else {\r\n        if (s > normH) {\r\n          normH = s;\r\n        }\r\n\r\n        i++;\r\n      }\r\n    }\r\n\r\n    if (normH >= 1.0E+10) {\r\n      kidx = 2;\r\n    } else {\r\n      boolean_T exitg1;\r\n      i = 0;\r\n      exitg1 = false;\r\n      while ((!exitg1) && (i <= 4)) {\r\n        boolean_T guard2 = false;\r\n        normH = rt_powd_snf(10.0, (real_T)i) * 1.4901161193847656E-7;\r\n        c_Linv[0] += normH;\r\n        c_SuJm_0[0] = c_Linv[0];\r\n        c_SuJm_0[1] = c_Linv[1];\r\n        c_SuJm_0[2] = c_Linv[2];\r\n        c_Linv[3] += normH;\r\n        c_SuJm_0[3] = c_Linv[3];\r\n        kidx = xpotrf(c_SuJm_0);\r\n        guard2 = false;\r\n        if (kidx == 0) {\r\n          if (c_SuJm_0[0] > c_SuJm_0[3]) {\r\n            normH = c_SuJm_0[3];\r\n          } else if (rtIsNaN(c_SuJm_0[0])) {\r\n            if (!rtIsNaN(c_SuJm_0[3])) {\r\n              normH = c_SuJm_0[3];\r\n            } else {\r\n              normH = c_SuJm_0[0];\r\n            }\r\n          } else {\r\n            normH = c_SuJm_0[0];\r\n          }\r\n\r\n          if (normH > 1.4901161193847656E-7) {\r\n            kidx = 1;\r\n            exitg1 = true;\r\n          } else {\r\n            guard2 = true;\r\n          }\r\n        } else {\r\n          guard2 = true;\r\n        }\r\n\r\n        if (guard2) {\r\n          kidx = 3;\r\n          i++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (kidx > 1) {\r\n    *u = old_u + b_uoff;\r\n    for (i = 0; i < 11; i++) {\r\n      useq[i] = *u;\r\n    }\r\n\r\n    *status = -2.0;\r\n  } else {\r\n    c_Linv[0] = 1.0;\r\n    c_Linv[1] = 0.0;\r\n    c_Linv[2] = 0.0;\r\n    c_Linv[3] = 1.0;\r\n    trisolve(c_SuJm_0, c_Linv);\r\n    *iAout = iA;\r\n    for (kidx = 0; kidx < 2; kidx++) {\r\n      real_T WuI2Jm_0;\r\n      real_T c_Kv_0;\r\n      c_SuJm_0[kidx] = 0.0;\r\n      i = kidx << 1;\r\n      normH = c_Linv[i];\r\n      c_SuJm_0[kidx] += normH * c_Linv[0];\r\n      s = c_Linv[i + 1];\r\n      c_SuJm_0[kidx] += s * c_Linv[1];\r\n      c_SuJm_0[kidx + 2] = 0.0;\r\n      c_SuJm_0[kidx + 2] += normH * c_Linv[2];\r\n      c_SuJm_0[kidx + 2] += s * c_Linv[3];\r\n      normH = 0.0;\r\n      for (i = 0; i < 6; i++) {\r\n        normH += c_Kx[6 * kidx + i] * x[i];\r\n      }\r\n\r\n      s = 0.0;\r\n      for (i = 0; i < 30; i++) {\r\n        s += WySuJm[30 * kidx + i] * rseq[i];\r\n      }\r\n\r\n      c_Kv_0 = 0.0;\r\n      for (i = 0; i < 11; i++) {\r\n        c_Kv_0 += c_Kv[11 * kidx + i] * vseq[i];\r\n      }\r\n\r\n      WuI2Jm_0 = 0.0;\r\n      for (i = 0; i < 10; i++) {\r\n        WuI2Jm_0 += WuI2Jm[10 * kidx + i] * b_utarget[i];\r\n      }\r\n\r\n      b_a_0[kidx] = (((normH + s) + c_Ku1[kidx] * old_u) + c_Kv_0) + WuI2Jm_0;\r\n      varargin_1[kidx] = 0.0;\r\n    }\r\n\r\n    varargin_1[0] -= c_SuJm_0[0] * b_a_0[0];\r\n    *status = 1.0;\r\n    *u = ((varargin_1[0] - b_a_0[1] * c_SuJm_0[2]) + old_u) + b_uoff;\r\n  }\r\n}\r\n\r\n/* Model step function */\r\nvoid TorqueVectoring_step(void)\r\n{\r\n  real_T CovMat[81];\r\n  real_T Bu[66];\r\n  real_T Bv[66];\r\n  real_T b_tmp[63];\r\n  real_T b_B[48];\r\n  real_T L_tmp[36];\r\n  real_T L_tmp_0[36];\r\n  real_T L_tmp_1[36];\r\n  real_T b_A[36];\r\n  real_T Dv[33];\r\n  real_T rseq[30];\r\n  real_T Cm_0[18];\r\n  real_T L[18];\r\n  real_T b_C[18];\r\n  real_T tmp[18];\r\n  real_T tmp_0[18];\r\n  real_T rtb_useq[11];\r\n  real_T vseq[11];\r\n  real_T b_utarget[10];\r\n  real_T rtb_A[9];\r\n  real_T rtb_C[9];\r\n  real_T b_xoff[6];\r\n  real_T xk[6];\r\n  real_T xk_0[6];\r\n  real_T Y[3];\r\n  real_T rtb_VectorConcatenate[3];\r\n  real_T rtb_VectorConcatenate1[3];\r\n  real_T rtb_X[3];\r\n  real_T rtb_C_tmp_0;\r\n  real_T rtb_C_tmp_1;\r\n  real_T rtb_C_tmp_2;\r\n  real_T rtb_C_tmp_3;\r\n  real_T rtb_Desiredyawratereferencedegs;\r\n  real_T rtb_Gain_e;\r\n  int32_T i;\r\n  int32_T r1;\r\n  int32_T r3;\r\n  int32_T rtb_C_tmp;\r\n  int32_T rtemp;\r\n  int8_T Cm[198];\r\n  int8_T c_B[9];\r\n  int8_T UnknownIn[7];\r\n  static const real_T c[36] = { -0.01, 0.0, 0.0, 0.0, 0.0, 0.0, -100.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.005, 0.0076500000000000005, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    1.0 };\r\n\r\n  static const real_T d[48] = { 0.0, 0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\r\n\r\n  static const int8_T e[18] = { 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0,\r\n    0, 1 };\r\n\r\n  static const int8_T b_D[24] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\r\n    0, 0, 0, 1, 0, 0, 0, 1 };\r\n\r\n  int32_T rtb_C_tmp_tmp;\r\n  boolean_T tmp_1;\r\n\r\n  /* SignalConversion generated from: '<S10>/Vector Concatenate' incorporates:\r\n   *  Inport: '<Root>/LateralVelocity'\r\n   */\r\n  rtb_VectorConcatenate[0] = rtU.LateralVelocity;\r\n\r\n  /* SignalConversion generated from: '<S10>/Vector Concatenate' incorporates:\r\n   *  Inport: '<Root>/VehicleYawRate'\r\n   */\r\n  rtb_VectorConcatenate[1] = rtU.VehicleYawRate;\r\n\r\n  /* SignalConversion generated from: '<S10>/Vector Concatenate' incorporates:\r\n   *  Inport: '<Root>/StrAngleDeg'\r\n   */\r\n  rtb_VectorConcatenate[2] = rtU.StrAngleDeg;\r\n\r\n  /* Fcn: '<S6>/Fcn2' incorporates:\r\n   *  Inport: '<Root>/VehicleSpeed'\r\n   */\r\n  rtb_Gain_e = ((real_T)(rtU.VehicleSpeed == 0.0) + rtU.VehicleSpeed) +\r\n    2.2204460492503131e-16;\r\n\r\n  /* Product: '<S6>/Divide' incorporates:\r\n   *  Constant: '<S6>/Constant'\r\n   *  Gain: '<S6>/Gain'\r\n   *  Gain: '<S6>/Gain1'\r\n   *  Inport: '<Root>/StrAngleDeg'\r\n   *  Math: '<S6>/Square'\r\n   *  Product: '<S6>/Product'\r\n   *  Sum: '<S6>/Plus'\r\n   */\r\n  rtb_Desiredyawratereferencedegs = 0.2 * rtU.StrAngleDeg * rtb_Gain_e /\r\n    (rtb_Gain_e * rtb_Gain_e * 0.0 + 1.53);\r\n\r\n  /* Gain: '<S6>/Gain2' incorporates:\r\n   *  Product: '<S6>/Divide1'\r\n   */\r\n  rtb_Gain_e = 1.0 / rtb_Gain_e * 19.62 * 57.295779513082323;\r\n\r\n  /* MATLAB Function: '<S6>/MATLAB Function' */\r\n  if (fabs(rtb_Desiredyawratereferencedegs) < rtb_Gain_e) {\r\n    rtb_VectorConcatenate1[1] = rtb_Desiredyawratereferencedegs;\r\n  } else {\r\n    if (rtb_Desiredyawratereferencedegs < 0.0) {\r\n      rtb_Desiredyawratereferencedegs = -1.0;\r\n    } else if (rtb_Desiredyawratereferencedegs > 0.0) {\r\n      rtb_Desiredyawratereferencedegs = 1.0;\r\n    } else if (rtb_Desiredyawratereferencedegs == 0.0) {\r\n      rtb_Desiredyawratereferencedegs = 0.0;\r\n    } else {\r\n      rtb_Desiredyawratereferencedegs = (rtNaN);\r\n    }\r\n\r\n    rtb_VectorConcatenate1[1] = rtb_Gain_e * rtb_Desiredyawratereferencedegs;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S6>/MATLAB Function' */\r\n\r\n  /* MATLAB Function: '<S10>/MATLAB Function' incorporates:\r\n   *  Inport: '<Root>/LateralVelocity'\r\n   *  Inport: '<Root>/StrAngleDeg'\r\n   *  Inport: '<Root>/VehicleSpeed'\r\n   *  Inport: '<Root>/VehicleYawRate'\r\n   */\r\n  rtb_A[0] = -0.01;\r\n  rtb_A[3] = ((-(rtU.VehicleSpeed * rtU.VehicleSpeed) * 200.0 - 0.765) + 0.765) /\r\n    200.0;\r\n  rtb_A[6] = 0.005;\r\n  rtb_A[1] = 0.0;\r\n  rtb_A[2] = 0.0;\r\n  rtb_A[4] = 0.0;\r\n  rtb_A[5] = 0.0;\r\n  rtb_A[7] = 0.0076500000000000005;\r\n  rtb_A[8] = 0.0;\r\n  memset(&rtb_C[0], 0, 9U * sizeof(real_T));\r\n  rtb_X[0] = rtU.LateralVelocity;\r\n  rtb_X[1] = rtU.VehicleYawRate;\r\n  rtb_X[2] = rtU.StrAngleDeg;\r\n  rtb_C[0] = 1.0;\r\n\r\n  /* MATLAB Function: '<S41>/FixedHorizonOptimizer' incorporates:\r\n   *  MATLAB Function: '<S10>/MATLAB Function'\r\n   */\r\n  Y[0] = 0.0;\r\n\r\n  /* MATLAB Function: '<S10>/MATLAB Function' */\r\n  rtb_C[4] = 1.0;\r\n\r\n  /* MATLAB Function: '<S41>/FixedHorizonOptimizer' incorporates:\r\n   *  MATLAB Function: '<S10>/MATLAB Function'\r\n   */\r\n  Y[1] = 0.01;\r\n\r\n  /* MATLAB Function: '<S10>/MATLAB Function' */\r\n  rtb_C[8] = 1.0;\r\n\r\n  /* MATLAB Function: '<S41>/FixedHorizonOptimizer' incorporates:\r\n   *  Inport: '<Root>/LateralVelocity'\r\n   *  Inport: '<Root>/StrAngleDeg'\r\n   *  Inport: '<Root>/VehicleYawRate'\r\n   *  MATLAB Function: '<S10>/MATLAB Function'\r\n   *  Memory: '<S13>/LastPcov'\r\n   *  Memory: '<S13>/last_x'\r\n   */\r\n  Y[2] = 0.0;\r\n  memset(&Bu[0], 0, 66U * sizeof(real_T));\r\n  memset(&Bv[0], 0, 66U * sizeof(real_T));\r\n  memset(&Dv[0], 0, 33U * sizeof(real_T));\r\n  memset(&Cm[0], 0, 198U * sizeof(int8_T));\r\n  memcpy(&b_A[0], &c[0], 36U * sizeof(real_T));\r\n  memcpy(&b_B[0], &d[0], 48U * sizeof(real_T));\r\n  for (i = 0; i < 18; i++) {\r\n    b_C[i] = e[i];\r\n  }\r\n\r\n  for (i = 0; i < 3; i++) {\r\n    b_B[i] = Y[i];\r\n    b_C[3 * i] = rtb_C[3 * i];\r\n    b_A[6 * i] = rtb_A[3 * i];\r\n    r3 = 3 * i + 1;\r\n    b_C[r3] = rtb_C[r3];\r\n    b_A[6 * i + 1] = rtb_A[r3];\r\n    r3 = 3 * i + 2;\r\n    b_C[r3] = rtb_C[r3];\r\n    b_A[6 * i + 2] = rtb_A[r3];\r\n  }\r\n\r\n  for (i = 0; i < 6; i++) {\r\n    Bu[i] = b_B[i];\r\n    Bv[i] = b_B[i + 6];\r\n    Cm[3 * i] = (int8_T)b_C[3 * i];\r\n    r3 = 3 * i + 1;\r\n    Cm[r3] = (int8_T)b_C[r3];\r\n    r3 = 3 * i + 2;\r\n    Cm[r3] = (int8_T)b_C[r3];\r\n  }\r\n\r\n  for (i = 0; i < 7; i++) {\r\n    UnknownIn[i] = 0;\r\n  }\r\n\r\n  UnknownIn[0] = 1;\r\n  for (i = 0; i < 6; i++) {\r\n    UnknownIn[i + 1] = (int8_T)(i + 3);\r\n  }\r\n\r\n  for (i = 0; i < 7; i++) {\r\n    for (r3 = 0; r3 < 6; r3++) {\r\n      b_tmp[r3 + 9 * i] = b_B[(UnknownIn[i] - 1) * 6 + r3];\r\n    }\r\n\r\n    r3 = (UnknownIn[i] - 1) * 3;\r\n    b_tmp[9 * i + 6] = b_D[r3];\r\n    b_tmp[9 * i + 7] = b_D[r3 + 1];\r\n    b_tmp[9 * i + 8] = b_D[r3 + 2];\r\n  }\r\n\r\n  for (i = 0; i < 9; i++) {\r\n    for (r3 = 0; r3 < 9; r3++) {\r\n      rtemp = 9 * r3 + i;\r\n      CovMat[rtemp] = 0.0;\r\n      for (r1 = 0; r1 < 7; r1++) {\r\n        CovMat[rtemp] += b_tmp[9 * r1 + i] * b_tmp[9 * r1 + r3];\r\n      }\r\n    }\r\n  }\r\n\r\n  Dv[0] = 0.0;\r\n  Dv[1] = 0.0;\r\n  Dv[2] = 0.0;\r\n  for (i = 0; i < 6; i++) {\r\n    b_xoff[i] = 0.0;\r\n  }\r\n\r\n  Y[0] = rtU.LateralVelocity;\r\n  Y[1] = rtU.VehicleYawRate;\r\n  Y[2] = rtU.StrAngleDeg;\r\n  memset(&b_utarget[0], 0, 10U * sizeof(real_T));\r\n  for (i = 0; i < 3; i++) {\r\n    b_xoff[i] = rtb_X[i];\r\n    Bv[i] = (rtb_A[i + 3] * rtU.VehicleYawRate + rtb_A[i] * rtU.LateralVelocity)\r\n      + rtb_A[i + 6] * rtU.StrAngleDeg;\r\n  }\r\n\r\n  for (r1 = 0; r1 < 11; r1++) {\r\n    vseq[r1] = 1.0;\r\n  }\r\n\r\n  for (r1 = 0; r1 < 10; r1++) {\r\n    rseq[r1 * ny] = rtU.LateralVelocity - rtU.LateralVelocity;\r\n    rseq[r1 * ny + 1] = rtb_VectorConcatenate1[1] - rtU.VehicleYawRate;\r\n    rseq[r1 * ny + 2] = rtU.StrAngleDeg - rtU.StrAngleDeg;\r\n  }\r\n\r\n  for (i = 0; i < 9; i++) {\r\n    c_B[i] = 0;\r\n  }\r\n\r\n  for (r1 = 0; r1 < 3; r1++) {\r\n    c_B[r1 + 3 * r1] = 1;\r\n    for (i = 0; i < 6; i++) {\r\n      rtemp = 3 * i + r1;\r\n      L[i + 6 * r1] = Cm[rtemp];\r\n      Cm_0[rtemp] = 0.0;\r\n      for (r3 = 0; r3 < 6; r3++) {\r\n        Cm_0[rtemp] += (real_T)Cm[3 * r3 + r1] * rtDW.LastPcov_PreviousInput[6 *\r\n          i + r3];\r\n      }\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < 3; i++) {\r\n    for (r3 = 0; r3 < 3; r3++) {\r\n      rtb_Gain_e = 0.0;\r\n      for (r1 = 0; r1 < 6; r1++) {\r\n        rtb_Gain_e += Cm_0[3 * r1 + i] * L[6 * r3 + r1];\r\n      }\r\n\r\n      rtb_A[i + 3 * r3] = CovMat[((r3 + 6) * 9 + i) + 6] + rtb_Gain_e;\r\n    }\r\n  }\r\n\r\n  r1 = 0;\r\n  i = 1;\r\n  r3 = 2;\r\n  rtb_Gain_e = fabs(rtb_A[0]);\r\n  rtb_Desiredyawratereferencedegs = fabs(rtb_A[1]);\r\n  if (rtb_Desiredyawratereferencedegs > rtb_Gain_e) {\r\n    rtb_Gain_e = rtb_Desiredyawratereferencedegs;\r\n    r1 = 1;\r\n    i = 0;\r\n  }\r\n\r\n  if (fabs(rtb_A[2]) > rtb_Gain_e) {\r\n    r1 = 2;\r\n    i = 1;\r\n    r3 = 0;\r\n  }\r\n\r\n  rtb_A[i] /= rtb_A[r1];\r\n  rtb_A[r3] /= rtb_A[r1];\r\n  rtb_A[i + 3] -= rtb_A[r1 + 3] * rtb_A[i];\r\n  rtb_A[r3 + 3] -= rtb_A[r1 + 3] * rtb_A[r3];\r\n  rtb_A[i + 6] -= rtb_A[r1 + 6] * rtb_A[i];\r\n  rtb_A[r3 + 6] -= rtb_A[r1 + 6] * rtb_A[r3];\r\n  if (fabs(rtb_A[r3 + 3]) > fabs(rtb_A[i + 3])) {\r\n    rtemp = i;\r\n    i = r3;\r\n    r3 = rtemp;\r\n  }\r\n\r\n  rtb_A[r3 + 3] /= rtb_A[i + 3];\r\n  rtb_A[r3 + 6] -= rtb_A[r3 + 3] * rtb_A[i + 6];\r\n  rtb_C[3 * r1] = (real_T)c_B[0] / rtb_A[r1];\r\n  rtb_Desiredyawratereferencedegs = rtb_A[r1 + 3];\r\n  rtb_C[3 * i] = (real_T)c_B[3] - rtb_C[3 * r1] *\r\n    rtb_Desiredyawratereferencedegs;\r\n  rtb_Gain_e = rtb_A[r1 + 6];\r\n  rtb_C[3 * r3] = (real_T)c_B[6] - rtb_C[3 * r1] * rtb_Gain_e;\r\n  rtb_C_tmp_0 = rtb_A[i + 3];\r\n  rtb_C[3 * i] /= rtb_C_tmp_0;\r\n  rtb_C_tmp_1 = rtb_A[i + 6];\r\n  rtb_C[3 * r3] -= rtb_C[3 * i] * rtb_C_tmp_1;\r\n  rtb_C_tmp_2 = rtb_A[r3 + 6];\r\n  rtb_C[3 * r3] /= rtb_C_tmp_2;\r\n  rtb_C_tmp_3 = rtb_A[r3 + 3];\r\n  rtb_C[3 * i] -= rtb_C[3 * r3] * rtb_C_tmp_3;\r\n  rtb_C[3 * r1] -= rtb_C[3 * r3] * rtb_A[r3];\r\n  rtb_C[3 * r1] -= rtb_C[3 * i] * rtb_A[i];\r\n  rtemp = 3 * r1 + 1;\r\n  rtb_C[rtemp] = (real_T)c_B[1] / rtb_A[r1];\r\n  rtb_C_tmp = 3 * i + 1;\r\n  rtb_C[rtb_C_tmp] = (real_T)c_B[4] - rtb_C[rtemp] *\r\n    rtb_Desiredyawratereferencedegs;\r\n  rtb_C_tmp_tmp = 3 * r3 + 1;\r\n  rtb_C[rtb_C_tmp_tmp] = (real_T)c_B[7] - rtb_C[rtemp] * rtb_Gain_e;\r\n  rtb_C[rtb_C_tmp] /= rtb_C_tmp_0;\r\n  rtb_C[rtb_C_tmp_tmp] -= rtb_C[rtb_C_tmp] * rtb_C_tmp_1;\r\n  rtb_C[rtb_C_tmp_tmp] /= rtb_C_tmp_2;\r\n  rtb_C[rtb_C_tmp] -= rtb_C[rtb_C_tmp_tmp] * rtb_C_tmp_3;\r\n  rtb_C[rtemp] -= rtb_C[rtb_C_tmp_tmp] * rtb_A[r3];\r\n  rtb_C[rtemp] -= rtb_C[rtb_C_tmp] * rtb_A[i];\r\n  rtemp = 3 * r1 + 2;\r\n  rtb_C[rtemp] = (real_T)c_B[2] / rtb_A[r1];\r\n  rtb_C_tmp = 3 * i + 2;\r\n  rtb_C[rtb_C_tmp] = (real_T)c_B[5] - rtb_C[rtemp] *\r\n    rtb_Desiredyawratereferencedegs;\r\n  rtb_C_tmp_tmp = 3 * r3 + 2;\r\n  rtb_C[rtb_C_tmp_tmp] = (real_T)c_B[8] - rtb_C[rtemp] * rtb_Gain_e;\r\n  rtb_C[rtb_C_tmp] /= rtb_C_tmp_0;\r\n  rtb_C[rtb_C_tmp_tmp] -= rtb_C[rtb_C_tmp] * rtb_C_tmp_1;\r\n  rtb_C[rtb_C_tmp_tmp] /= rtb_C_tmp_2;\r\n  rtb_C[rtb_C_tmp] -= rtb_C[rtb_C_tmp_tmp] * rtb_C_tmp_3;\r\n  rtb_C[rtemp] -= rtb_C[rtb_C_tmp_tmp] * rtb_A[r3];\r\n  rtb_C[rtemp] -= rtb_C[rtb_C_tmp] * rtb_A[i];\r\n  for (i = 0; i < 6; i++) {\r\n    for (r3 = 0; r3 < 6; r3++) {\r\n      rtemp = 6 * r3 + i;\r\n      L_tmp[rtemp] = 0.0;\r\n      for (r1 = 0; r1 < 6; r1++) {\r\n        L_tmp[rtemp] += b_A[6 * r1 + i] * rtDW.LastPcov_PreviousInput[6 * r3 +\r\n          r1];\r\n      }\r\n    }\r\n\r\n    for (r3 = 0; r3 < 3; r3++) {\r\n      rtb_Gain_e = 0.0;\r\n      for (r1 = 0; r1 < 6; r1++) {\r\n        rtb_Gain_e += L_tmp[6 * r1 + i] * L[6 * r3 + r1];\r\n      }\r\n\r\n      Cm_0[i + 6 * r3] = CovMat[(r3 + 6) * 9 + i] + rtb_Gain_e;\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < 6; i++) {\r\n    for (r3 = 0; r3 < 3; r3++) {\r\n      rtemp = 6 * r3 + i;\r\n      L[rtemp] = 0.0;\r\n      L[rtemp] += rtb_C[3 * r3] * Cm_0[i];\r\n      L[rtemp] += rtb_C[3 * r3 + 1] * Cm_0[i + 6];\r\n      L[rtemp] += rtb_C[3 * r3 + 2] * Cm_0[i + 12];\r\n    }\r\n\r\n    xk[i] = rtDW.last_x_PreviousInput[i] - b_xoff[i];\r\n  }\r\n\r\n  for (i = 0; i < 3; i++) {\r\n    rtb_Gain_e = 0.0;\r\n    for (r3 = 0; r3 < 6; r3++) {\r\n      rtb_Gain_e += (real_T)Cm[3 * r3 + i] * xk[r3];\r\n    }\r\n\r\n    rtb_VectorConcatenate1[i] = (rtb_VectorConcatenate[i] - Y[i]) - rtb_Gain_e;\r\n  }\r\n\r\n  for (i = 0; i < 6; i++) {\r\n    for (r3 = 0; r3 < 3; r3++) {\r\n      r1 = 6 * r3 + i;\r\n      tmp[r1] = 0.0;\r\n      for (rtemp = 0; rtemp < 6; rtemp++) {\r\n        tmp[r1] += rtDW.LastPcov_PreviousInput[6 * rtemp + i] * (real_T)Cm[3 *\r\n          rtemp + r3];\r\n      }\r\n    }\r\n\r\n    rtb_Gain_e = 0.0;\r\n    for (r3 = 0; r3 < 3; r3++) {\r\n      r1 = 6 * r3 + i;\r\n      tmp_0[r1] = 0.0;\r\n      tmp_0[r1] += rtb_C[3 * r3] * tmp[i];\r\n      tmp_0[r1] += rtb_C[3 * r3 + 1] * tmp[i + 6];\r\n      tmp_0[r1] += rtb_C[3 * r3 + 2] * tmp[i + 12];\r\n      rtb_Gain_e += tmp_0[r1] * rtb_VectorConcatenate1[r3];\r\n    }\r\n\r\n    xk_0[i] = xk[i] + rtb_Gain_e;\r\n  }\r\n\r\n  /* Update for Memory: '<S13>/Memory' incorporates:\r\n   *  MATLAB Function: '<S10>/MATLAB Function'\r\n   *  MATLAB Function: '<S41>/FixedHorizonOptimizer'\r\n   *  UnitDelay: '<S13>/last_mv'\r\n   */\r\n  mpcblock_optimizer(rseq, vseq, xk_0, rtDW.last_mv_DSTATE,\r\n                     rtDW.Memory_PreviousInput, b_utarget, 0.0, b_A, Bu, Bv, b_C,\r\n                     Dv, &rtb_Desiredyawratereferencedegs, rtb_useq, &rtb_Gain_e,\r\n                     &tmp_1);\r\n  rtDW.Memory_PreviousInput = tmp_1;\r\n\r\n  /* MATLAB Function: '<S41>/FixedHorizonOptimizer' */\r\n  for (i = 0; i < 6; i++) {\r\n    for (r3 = 0; r3 < 6; r3++) {\r\n      rtemp = 6 * r3 + i;\r\n      L_tmp_0[rtemp] = 0.0;\r\n      for (r1 = 0; r1 < 6; r1++) {\r\n        L_tmp_0[rtemp] += L_tmp[6 * r1 + i] * b_A[6 * r1 + r3];\r\n      }\r\n\r\n      L_tmp_1[rtemp] = 0.0;\r\n      L_tmp_1[rtemp] += Cm_0[i] * L[r3];\r\n      L_tmp_1[rtemp] += Cm_0[i + 6] * L[r3 + 6];\r\n      L_tmp_1[rtemp] += Cm_0[i + 12] * L[r3 + 12];\r\n    }\r\n  }\r\n\r\n  /* DeadZone: '<S3>/Dead Zone' incorporates:\r\n   *  Inport: '<Root>/StrAngleDeg'\r\n   */\r\n  if (rtU.StrAngleDeg > 10.0) {\r\n    rtb_Gain_e = rtU.StrAngleDeg - 10.0;\r\n  } else if (rtU.StrAngleDeg >= -10.0) {\r\n    rtb_Gain_e = 0.0;\r\n  } else {\r\n    rtb_Gain_e = rtU.StrAngleDeg - -10.0;\r\n  }\r\n\r\n  /* End of DeadZone: '<S3>/Dead Zone' */\r\n\r\n  /* Abs: '<S3>/Abs' */\r\n  rtb_Gain_e = fabs(rtb_Gain_e);\r\n\r\n  /* Signum: '<S3>/Sign' */\r\n  if (rtb_Gain_e > 0.0) {\r\n    rtb_Gain_e = 1.0;\r\n  } else if (rtb_Gain_e == 0.0) {\r\n    rtb_Gain_e = 0.0;\r\n  } else {\r\n    rtb_Gain_e = (rtNaN);\r\n  }\r\n\r\n  /* End of Signum: '<S3>/Sign' */\r\n\r\n  /* Saturate: '<S8>/Yaw moment saturation' incorporates:\r\n   *  MATLAB Function: '<S41>/FixedHorizonOptimizer'\r\n   */\r\n  if (rtb_Desiredyawratereferencedegs > 3600.0) {\r\n    rtb_C_tmp_0 = 3600.0;\r\n  } else if (rtb_Desiredyawratereferencedegs < -3600.0) {\r\n    rtb_C_tmp_0 = -3600.0;\r\n  } else {\r\n    rtb_C_tmp_0 = rtb_Desiredyawratereferencedegs;\r\n  }\r\n\r\n  /* End of Saturate: '<S8>/Yaw moment saturation' */\r\n\r\n  /* Gain: '<S4>/Gain' incorporates:\r\n   *  Constant: '<S2>/Constant'\r\n   *  Constant: '<S7>/Constant'\r\n   *  Gain: '<S4>/Gain1'\r\n   *  Gain: '<S7>/Gain1'\r\n   *  Gain: '<S7>/Gain3'\r\n   *  Inport: '<Root>/FeedbackEnabled'\r\n   *  Inport: '<Root>/TorqueVectoringEnabled'\r\n   *  Inport: '<Root>/VehicleSpeed'\r\n   *  Logic: '<S1>/AND'\r\n   *  Logic: '<S8>/AND'\r\n   *  Product: '<S7>/Divide1'\r\n   *  Product: '<S8>/Product2'\r\n   *  RelationalOperator: '<S2>/Compare'\r\n   */\r\n  rtb_Gain_e = (real_T)(rtU.FeedbackEnabled && ((rtb_Gain_e != 0.0) &&\r\n    (rtU.VehicleSpeed >= 2.4) && (rtU.TorqueVectoringEnabled != 0.0))) *\r\n    rtb_C_tmp_0 * 0.5 * 0.205 / 14.399999999999999 * 0.5;\r\n\r\n  /* Outport: '<Root>/TVFL' incorporates:\r\n   *  Gain: '<S4>/Gain'\r\n   */\r\n  rtY.TVFL = rtb_Gain_e;\r\n\r\n  /* Outport: '<Root>/TVFR' incorporates:\r\n   *  Gain: '<S4>/Gain'\r\n   */\r\n  rtY.TVFR = rtb_Gain_e;\r\n\r\n  /* Outport: '<Root>/TVRL' */\r\n  rtY.TVRL = rtb_Gain_e;\r\n\r\n  /* Outport: '<Root>/TVRR' */\r\n  rtY.TVRR = rtb_Gain_e;\r\n  for (i = 0; i < 6; i++) {\r\n    /* MATLAB Function: '<S41>/FixedHorizonOptimizer' */\r\n    rtb_Gain_e = 0.0;\r\n    for (r3 = 0; r3 < 6; r3++) {\r\n      r1 = 6 * i + r3;\r\n      L_tmp[r1] = CovMat[9 * i + r3] + (L_tmp_0[r1] - L_tmp_1[r1]);\r\n      rtb_Gain_e += b_A[6 * r3 + i] * xk[r3];\r\n    }\r\n\r\n    /* Update for Memory: '<S13>/last_x' incorporates:\r\n     *  MATLAB Function: '<S41>/FixedHorizonOptimizer'\r\n     */\r\n    rtDW.last_x_PreviousInput[i] = (((L[i + 6] * rtb_VectorConcatenate1[1] + L[i]\r\n      * rtb_VectorConcatenate1[0]) + L[i + 12] * rtb_VectorConcatenate1[2]) +\r\n      ((Bu[i] * rtb_Desiredyawratereferencedegs + rtb_Gain_e) + Bv[i])) +\r\n      b_xoff[i];\r\n  }\r\n\r\n  /* Update for UnitDelay: '<S13>/last_mv' incorporates:\r\n   *  MATLAB Function: '<S41>/FixedHorizonOptimizer'\r\n   */\r\n  rtDW.last_mv_DSTATE = rtb_Desiredyawratereferencedegs;\r\n\r\n  /* Update for Memory: '<S13>/LastPcov' incorporates:\r\n   *  MATLAB Function: '<S41>/FixedHorizonOptimizer'\r\n   */\r\n  for (i = 0; i < 6; i++) {\r\n    for (r3 = 0; r3 < 6; r3++) {\r\n      /* MATLAB Function: '<S41>/FixedHorizonOptimizer' */\r\n      r1 = 6 * i + r3;\r\n      rtDW.LastPcov_PreviousInput[r1] = (L_tmp[6 * r3 + i] + L_tmp[r1]) * 0.5;\r\n    }\r\n  }\r\n\r\n  /* End of Update for Memory: '<S13>/LastPcov' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid TorqueVectoring_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* InitializeConditions for Memory: '<S13>/LastPcov' */\r\n  memcpy(&rtDW.LastPcov_PreviousInput[0], &rtConstP.LastPcov_InitialCondition[0],\r\n         36U * sizeof(real_T));\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"TorqueVectoring.h","type":"header","group":"model","path":"C:\\Users\\eiakim\\Downloads\\ControlSystemsMPC-main\\ControlSystemsMPC-main\\Current\\TorqueVectoring_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: TorqueVectoring.h\r\n *\r\n * Code generated for Simulink model 'TorqueVectoring'.\r\n *\r\n * Model version                  : 1.0\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Mar 27 18:22:20 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_TorqueVectoring_h_\r\n#define RTW_HEADER_TorqueVectoring_h_\r\n#include \"rtwtypes.h\"\r\n#include <stddef.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#ifndef TorqueVectoring_COMMON_INCLUDES_\r\n#define TorqueVectoring_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* TorqueVectoring_COMMON_INCLUDES_ */\r\n\r\n/* Model Code Variants */\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_WTmPWsEMvOzNnnAVv5fQNC_\r\n#define DEFINED_TYPEDEF_FOR_struct_WTmPWsEMvOzNnnAVv5fQNC_\r\n\r\ntypedef struct {\r\n  int32_T MaxIterations;\r\n  real_T ConstraintTolerance;\r\n  boolean_T UseWarmStart;\r\n} struct_WTmPWsEMvOzNnnAVv5fQNC;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_WHjMt45Sk148iktWsfFxl_\r\n#define DEFINED_TYPEDEF_FOR_struct_WHjMt45Sk148iktWsfFxl_\r\n\r\ntypedef struct {\r\n  int32_T MaxIterations;\r\n  real_T ConstraintTolerance;\r\n  real_T OptimalityTolerance;\r\n  real_T ComplementarityTolerance;\r\n  real_T StepTolerance;\r\n} struct_WHjMt45Sk148iktWsfFxl;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_lnQ9KXdSZFplhcBp5LBCc_\r\n#define DEFINED_TYPEDEF_FOR_struct_lnQ9KXdSZFplhcBp5LBCc_\r\n\r\ntypedef struct {\r\n  int32_T MaxIterations;\r\n  real_T ConstraintTolerance;\r\n  real_T DiscreteConstraintTolerance;\r\n  boolean_T RoundingAtRootNode;\r\n  int32_T MaxPendingNodes;\r\n} struct_lnQ9KXdSZFplhcBp5LBCc;\r\n\r\n#endif\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T last_x_PreviousInput[6];      /* '<S13>/last_x' */\r\n  real_T LastPcov_PreviousInput[36];   /* '<S13>/LastPcov' */\r\n  real_T last_mv_DSTATE;               /* '<S13>/last_mv' */\r\n  boolean_T Memory_PreviousInput;      /* '<S13>/Memory' */\r\n} DW;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Expression: lastPcov\r\n   * Referenced by: '<S13>/LastPcov'\r\n   */\r\n  real_T LastPcov_InitialCondition[36];\r\n} ConstP;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T StrAngleDeg;                  /* '<Root>/StrAngleDeg' */\r\n  real_T VehicleSpeed;                 /* '<Root>/VehicleSpeed' */\r\n  real_T TorqueVectoringEnabled;       /* '<Root>/TorqueVectoringEnabled' */\r\n  real_T VehicleYawRate;               /* '<Root>/VehicleYawRate' */\r\n  boolean_T FeedbackEnabled;           /* '<Root>/FeedbackEnabled' */\r\n  boolean_T FeedForwardEnabled;        /* '<Root>/FeedForwardEnabled' */\r\n  real_T LateralVelocity;              /* '<Root>/LateralVelocity' */\r\n} ExtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T TVFL;                         /* '<Root>/TVFL' */\r\n  real_T TVFR;                         /* '<Root>/TVFR' */\r\n  real_T TVRL;                         /* '<Root>/TVRL' */\r\n  real_T TVRR;                         /* '<Root>/TVRR' */\r\n} ExtY;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY rtY;\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstP rtConstP;\r\n\r\n/* Model entry point functions */\r\nextern void TorqueVectoring_initialize(void);\r\nextern void TorqueVectoring_step(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S13>/Floor' : Unused code path elimination\r\n * Block '<S13>/Floor1' : Unused code path elimination\r\n * Block '<S14>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S15>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S16>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S17>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S18>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S19>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S20>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S21>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S22>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S23>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S24>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S25>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S26>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S27>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S28>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S29>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S30>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S31>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S32>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S33>/Matrix Dimension Check' : Unused code path elimination\r\n * Block '<S34>/Vector Dimension Check' : Unused code path elimination\r\n * Block '<S35>/Vector Dimension Check' : Unused code path elimination\r\n * Block '<S36>/Vector Dimension Check' : Unused code path elimination\r\n * Block '<S37>/Vector Dimension Check' : Unused code path elimination\r\n * Block '<S38>/Vector Dimension Check' : Unused code path elimination\r\n * Block '<S39>/Vector Dimension Check' : Unused code path elimination\r\n * Block '<S40>/Vector Dimension Check' : Unused code path elimination\r\n * Block '<S13>/useq_scale' : Unused code path elimination\r\n * Block '<S13>/useq_scale1' : Unused code path elimination\r\n * Block '<S13>/ym_zero' : Unused code path elimination\r\n * Block '<S11>/m_zero' : Unused code path elimination\r\n * Block '<S11>/p_zero' : Unused code path elimination\r\n * Block '<S10>/Scope' : Unused code path elimination\r\n * Block '<S10>/Scope1' : Unused code path elimination\r\n * Block '<S9>/AND' : Unused code path elimination\r\n * Block '<S9>/Constant' : Unused code path elimination\r\n * Block '<S9>/Product' : Unused code path elimination\r\n * Block '<S9>/Product2' : Unused code path elimination\r\n * Block '<S9>/Yaw moment saturation' : Unused code path elimination\r\n * Block '<S13>/Reshape' : Reshape block reduction\r\n * Block '<S13>/Reshape1' : Reshape block reduction\r\n * Block '<S13>/Reshape2' : Reshape block reduction\r\n * Block '<S13>/Reshape3' : Reshape block reduction\r\n * Block '<S13>/Reshape4' : Reshape block reduction\r\n * Block '<S13>/Reshape5' : Reshape block reduction\r\n * Block '<S13>/ext.mv_scale' : Eliminated nontunable gain of 1\r\n * Block '<S13>/u_scale' : Eliminated nontunable gain of 1\r\n * Block '<S13>/umin_scale4' : Eliminated nontunable gain of 1\r\n * Block '<S13>/uref_scale' : Eliminated nontunable gain of 1\r\n * Block '<S13>/ymin_scale1' : Eliminated nontunable gain of 1\r\n * Block '<S13>/ymin_scale2' : Eliminated nontunable gain of 1\r\n * Block '<S10>/NominalU1' : Eliminated nontunable bias of 0\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'TorqueVectoring'\r\n * '<S1>'   : 'TorqueVectoring/Subsystem'\r\n * '<S2>'   : 'TorqueVectoring/Subsystem/Compare To Constant'\r\n * '<S3>'   : 'TorqueVectoring/Subsystem/If steering angle is between -10 and 10 degrees system is off '\r\n * '<S4>'   : 'TorqueVectoring/Subsystem/Yaw moment distribution'\r\n * '<S5>'   : 'TorqueVectoring/Subsystem/Yaw rate controller'\r\n * '<S6>'   : 'TorqueVectoring/Subsystem/Yaw rate reference calculation'\r\n * '<S7>'   : 'TorqueVectoring/Subsystem/Yaw moment distribution/Lateral torque distribution'\r\n * '<S8>'   : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type'\r\n * '<S9>'   : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedforward controller type'\r\n * '<S10>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type'\r\n * '<S11>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller'\r\n * '<S12>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/MATLAB Function'\r\n * '<S13>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC'\r\n * '<S14>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check'\r\n * '<S15>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check A'\r\n * '<S16>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check B'\r\n * '<S17>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check C'\r\n * '<S18>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check D'\r\n * '<S19>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check DX'\r\n * '<S20>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check U'\r\n * '<S21>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check X'\r\n * '<S22>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check Y'\r\n * '<S23>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check1'\r\n * '<S24>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Matrix Signal Check2'\r\n * '<S25>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check'\r\n * '<S26>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check1'\r\n * '<S27>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check2'\r\n * '<S28>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check3'\r\n * '<S29>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check4'\r\n * '<S30>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check5'\r\n * '<S31>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check6'\r\n * '<S32>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check7'\r\n * '<S33>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Preview Signal Check8'\r\n * '<S34>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Scalar Signal Check'\r\n * '<S35>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Scalar Signal Check1'\r\n * '<S36>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Scalar Signal Check2'\r\n * '<S37>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Vector Signal Check'\r\n * '<S38>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Vector Signal Check1'\r\n * '<S39>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/MPC Vector Signal Check6'\r\n * '<S40>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/moorx'\r\n * '<S41>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/optimizer'\r\n * '<S42>'  : 'TorqueVectoring/Subsystem/Yaw rate controller/Feedback controller type/PI controller type/Adaptive MPC Controller/MPC/optimizer/FixedHorizonOptimizer'\r\n * '<S43>'  : 'TorqueVectoring/Subsystem/Yaw rate reference calculation/MATLAB Function'\r\n */\r\n#endif                                 /* RTW_HEADER_TorqueVectoring_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"TorqueVectoring_data.c","type":"source","group":"data","path":"C:\\Users\\eiakim\\Downloads\\ControlSystemsMPC-main\\ControlSystemsMPC-main\\Current\\TorqueVectoring_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: TorqueVectoring_data.c\r\n *\r\n * Code generated for Simulink model 'TorqueVectoring'.\r\n *\r\n * Model version                  : 1.0\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Mar 27 18:22:20 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"TorqueVectoring.h\"\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstP rtConstP = {\r\n  /* Expression: lastPcov\r\n   * Referenced by: '<S13>/LastPcov'\r\n   */\r\n  { 0.99995014210330346, 1.2281771885021569E-18, 1.5071626417781368E-19,\r\n    6.9576200037709507E-6, 9.9243004996226948E-6, -3.3127157255606756E-18,\r\n    1.2281771885021569E-18, 9.9999999999999978E-5, -5.2285225027488508E-20,\r\n    1.7597713423363803E-18, -7.9894264467338809E-20, 2.73296008920717E-20,\r\n    1.5071626417781368E-19, -5.2285225027488508E-20, 1.1819944322044953E-30,\r\n    4.0530579303152628E-17, -5.1089536695713137E-18, 2.0667611905162605E-18,\r\n    6.9576200037709507E-6, 1.7597713423363803E-18, 4.0530579303152628E-17,\r\n    0.0014077289060602759, -4.1088708951106595E-6, -1.0924237588108321E-16,\r\n    9.9243004996226948E-6, -7.9894264467338809E-20, -5.1089536695713137E-18,\r\n    -4.1088708951106595E-6, 0.0010005416827222819, 1.4445657673304104E-16,\r\n    -3.3127157255606756E-18, 2.73296008920717E-20, 2.0667611905162605E-18,\r\n    -1.0924237588108321E-16, 1.4445657673304104E-16, 0.001000500125000512 }\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\eiakim\\Downloads\\ControlSystemsMPC-main\\ControlSystemsMPC-main\\Current\\TorqueVectoring_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'TorqueVectoring'.\r\n *\r\n * Model version                  : 1.0\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Mar 27 18:22:20 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex-M\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};